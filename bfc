#!/usr/bin/perl

use strict;
use warnings;
use Cwd;
use Youri::Package::RPM;
use Git;
use YAML::XS;
use HTTP::SimpleLinkChecker qw(check_link);
use Digest::SHA1;
use LWP::Simple qw(getstore is_error);
use LWP::UserAgent;
use HTTP::Request::Common qw(POST);
use HTTP::Status qw(status_message);
use Config::IniFiles;
use Net::Netrc;
use Term::ReadKey qw(ReadMode);

=head1 NAME

bfc - ABF command-line client

=head1 SYNOPSIS

bfc <action> [options]

=head2 Actions:

=over 8

=item f[etch]

fetch new sources from upstream

=item g[et]

get all sources for local build

=item p[ush]

push local changes to ABF

=item s[ync]

sync sources and patches

=item up[load]

upload sources to file store

=back

=head1 DESCRIPTION

Build farm client is an alternative ABF client. It helps managing git repos
and ABF tasks.

=cut

our $config = Config::IniFiles->new( -file => "/etc/bfc.conf" );
if (-r "$ENV{HOME}/.bfc.conf") {
    $config = Config::IniFiles->new(
        -file   => "$ENV{HOME}/.bfc.conf",
        -import => $config
    );
}

my $action = shift @ARGV || "";

for ($action) {
    /^c(lean)?[-_]?t(ree)?$/    ?   cleantree(@ARGV)    :
    /^f(etch)?$/                ?   fetch(@ARGV)        :
    /^g(et)?$/                  ?   get(@ARGV)          :
    /^p(ush)?$/		        ?   pushcmd(@ARGV)      :
    /^s(ync)?$/                 ?   sync(@ARGV)         :
    /^up(load)?$/               ?   upload(@ARGV)       :
    die "wrong syntax\n";
}

=head1 ACTIONS

=head2 cleantree

Clean git tree from binary files, e.g. tarballs. This command should not be
run directly but by B<git filter-branch>:

    git filter-branch --tree-filter 'bfc cleantree' -- --all

It finds binary files in git tree, add them to I<.abf.yml>, uploads to file
store and then removes. Before running this command ensure that you have
fetched all remote branches. Be very careful because pushing your changes
to remote repository will overwrite any commits added after your last fetch.
Use this two commands for push:

    git push --force --all
    git push --force --tags

=cut

sub cleantree {
    my @trackedfiles = <*>;
    my $abfyml = eval{ read_abfyml() };
    my $fs_baseurl = fs_baseurl();

    if ($abfyml) {
        foreach my $file (keys %{$abfyml->{sources}}) {
            if ($file ~~ @trackedfiles) {
                unless (checkfilestore($abfyml->{sources}{$file})) {
                    fs_upload($file);
                }
            }
        }
    }

    foreach my $file (@trackedfiles) {
        unless ($abfyml->{sources}{$file}) {
            unless (-T $file) {
                my $ctx = Digest::SHA1->new();
                open(my $FILE, "<", $file);
                $ctx->addfile($FILE);
                $abfyml->{sources}{$file} = $ctx->hexdigest();
                unless (checkfilestore($abfyml->{sources}{$file})) {
                    fs_upload($file);
                }
                `rm $file`;
            }
        }
    }

    YAML::XS::DumpFile('.abf.yml', $abfyml);
}

=head2 fetch

Fetch sources from upstream. Only new sources that are not available locally
nor at file store are downloaded.

=cut

sub fetch {
    my $spec = init_spec();
    my $abfyml = read_abfyml();

    my @sourceurls = ($spec->sources_url(), $spec->icon_url());
    @sourceurls = map { m/^(https?|ftp):/ ? $_ : () } @sourceurls;

    foreach (@sourceurls) {
        m([^/]+$);
        unless (-f $& or
            $abfyml->{sources}{$&} and checkfilestore($abfyml->{sources}{$&}))
        {
            print "$&\n";
            download($_, $&);
        }
    }
}

=head2 get

Get all sources to perform local build. If source file is available at file
store it is downloaded from there, otherwise URL specified in spec file
is used.

=cut

sub get {
    my $spec = init_spec();
    my $abfyml = read_abfyml();
    my @sourceurls = ($spec->sources_url(), $spec->icon_url());
    my $baseurl = $config->val('file-store', 'baseurl');

    foreach (@sourceurls) {
        m([^/]+$);
        unless (-f $&) {
            print "$&\n";
            if (my $sha1 = $abfyml->{sources}{$&}) {
                download("$baseurl/download/$sha1", $&);
            } else {
                download($_, $&);
            }
        }
    }
}

=head2 push

Push all commited changes to origin (like git push) and upload all files
specified in I<.abf.yml> to file store (if they are not alredy there). Files
for upload must be available locally; if they are not, run B<bfc fetch>
command before.

=cut

sub pushcmd {
    my $specfile = find_spec();
    my $spec = init_spec($specfile);
    my $git = Git->repository(cwd())
        or die "Not in the git working directory\n";

    $git->command('push', @_);
    upload();
}

=head2 sync

Read source files from spec file, add text (or zero-legth) ones to git tree
and binary ones to I<.abf.yml>. Files not mentioned in spec will be removed
from git tree and I<.abf.yml>. New source files must be available locally;
if they are not, run B<bfc fetch> command before.

=cut

sub sync {
    my $specfile = find_spec();
    my $spec = init_spec($specfile);
    my @sources = ($specfile, $spec->sources(), $spec->icon());
    my $git = Git->repository(cwd())
        or die "Not in the git working directory\n";
    my @trackedfiles = split /\n/, $git->command('ls-files');
    my @filestoupload;
    my $abfyml = read_abfyml();

    if ($abfyml) {
        foreach my $file (keys %{$abfyml->{sources}}) {
            if ($file ~~ @sources) {
                unless (checkfilestore($abfyml->{sources}{$file})) {
                    push @filestoupload, $file;
                }
            } else {
                delete $abfyml->{sources}{$file};
                print "$file removed from .abf.yml";
            }
        }
    }

    foreach my $file (@sources) {
        unless ($abfyml->{sources}{$file}) {
            if (-f $file) {
                if (-T _) {
                    unless ($file ~~ @trackedfiles) {
                        $git->command('add', $file);
                        print "$file added to git index\n";
                    }
                } else {
                    my $ctx = Digest::SHA1->new();
                    open(my $FILE, "<", $file);
                    $ctx->addfile($FILE);
                    $abfyml->{sources}{$file} = $ctx->hexdigest();
                    print "$file added to .abf.yml\n";
                    unless (checkfilestore($abfyml->{sources}{$file})) {
                        push @filestoupload, $file;
                    }
                }
            } else {
                warn "No such file: $file\n";
            }
        }
    }

    YAML::XS::DumpFile('.abf.yml', $abfyml);

    unless ('.abf.yml' ~~ @trackedfiles) {
        $git->command('add', '.abf.yml') and print "added .abf.yml\n";
    }
    push @sources, '.abf.yml';

    foreach my $file (@trackedfiles) {
        if ($file ~~ @sources) {
            if ($abfyml->{sources}{$file}) {
                $git->command('rm', '--cached', $file);
                print "$file removed from git index\n";
            }
        } else {
            $git->command('rm', $file);
            print "$file removed\n";
        }
    }

    if (@filestoupload) {
        print "\nYou need to upload following files to file store:\n";
        print join("\n", @filestoupload) . "\n";
    }
}

=head2 upload

Upload files listed in I<.abf.yml> to file store if they were not yet. If you
have updated your specfile, you should run

    bfc fetch && bfc sync

before to get sources locally and add them to I<.abf.yml>.

=cut

sub upload {
    my @files;
    if (@_) {
        @files = @_;
    } else {
        my $abfyml = read_abfyml();
        if ($abfyml) {
            foreach my $file (keys %{$abfyml->{sources}}) {
                unless (checkfilestore($abfyml->{sources}{$file})) {
                    if (-f $file) {
                        push @files, $file;
                    } else {
                        warn "No such file: $file\n";
                    }
                }
            }
        }
    }
    fs_upload(@files);
}

sub checkfilestore {
    my ($sha1) = @_ or return;
    my $baseurl = $config->val('file-store', 'baseurl');
    my $url = "$baseurl/download/$sha1";
    my $status = check_link($url);
    if ($status == 404) {
        return 0;
    } elsif ($status == 200) {
        return 1;
    } else {
        warn "Warning: requesting $url failed\n";
        warn "HTTP response: $status: $HTTP::SimpleLinkChecker::ERROR\n";
        return -1;
    }
 
}

sub find_spec {
    my ($specfile) = <*.spec>
        or die "Can't find any spec file\n";
    return $specfile;
}

sub init_spec {
    my ($specfile) = @_ ? @_ : (find_spec());
    my $rpm_class = Youri::Package::RPM->get_wrapper_class();
    set_rpm_dirs();
    my $spec = $rpm_class->new_spec($specfile, anyarch => 1, force => 1)
        or die "Can't parse spec file $specfile\n";
    return $spec;
}

sub read_abfyml {
    my $abfyml;
    if (-r '.abf.yml') {
        $abfyml = YAML::XS::LoadFile('.abf.yml');
    }
    return $abfyml;
}

sub set_rpm_dirs {
    my $rpm_class = Youri::Package::RPM->get_wrapper_class();
    foreach ("_sourcedir", "_specdir") {
        $rpm_class->add_macro("$_ " . cwd());
    }
}

sub download {
    my ($url, $file) = @_;
    my $rc = getstore($url, $file);
    if (is_error($rc)) {
        my $message = status_message($rc);
        warn "Can't download $_: $rc: $message\n";
    }
}

sub fs_upload {
    my $baseurl = fs_baseurl();
    foreach (@_) {
        my ($filename) = $_ =~ m{([^/]+)$};
        my $url = "$baseurl/api/v1/file_stores";
        $HTTP::Request::Common::DYNAMIC_FILE_UPLOAD = 1;
        my $request = POST $url,
                Content_Type    => 'form-data',
                Content         => [ name               => $filename,
                                    'file_store[file]'  => [$_] ];
        my $ua = LWP::UserAgent->new;
        print "Uploading $filename\n";
        my $result = $ua->request($request);
        if ($result->is_error()) {
            warn "Error uploading $filename: " .
                    $result->code . ": " .
                    $result->message . "\n";
            return;
        } else {
            return $result->content;
        }
    }
}

sub fs_baseurl {
    my $url = $config->val('file-store', 'baseurl');
    my $username = fs_username();
    my $password = fs_password();

    $url =~ s|(^\w+://)|$1${username}:${password}@|;
    $url =~ s|/$||;
    return $url;
}

sub fs_username {
    my ($hostname) = $config->val('file-store', 'baseurl') =~ m{(?<=://)([a-z0-9-.]+)};
    my $netrc = Net::Netrc->lookup(fs_hostname());
    my $username;
    if ($netrc) {
        $username = $netrc->login;
    } else {
        print "ABF file store username: ";
        $username = <>;
        chomp $username;
    }
    return $username;
}

sub fs_password {
    my $netrc = Net::Netrc->lookup(fs_hostname());
    my $password;
    if ($netrc) {
        $password = $netrc->password;
    } else {
        print "ABF file store password: ";
        ReadMode 'noecho';
        $password = <>;
        ReadMode 'restore';
        chomp $password;
    }
    return $password;
}

sub fs_hostname {
    $config->val('file-store', 'baseurl') =~ m{(?<=://)([a-z0-9-.]+)};
}

__END__

=head1 COPYRIGHT

Copyright (C) 2012, Dmitry Mikhirev

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

